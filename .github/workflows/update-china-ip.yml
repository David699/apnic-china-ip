name: Update China IP Ranges

on:
  schedule:
    # Run daily at 02:00 UTC (10:00 Beijing Time)
    - cron: '0 2 * * *'
  workflow_dispatch:  # Allow manual trigger
  push:
    branches:
      - master
    paths:
      - '.github/workflows/update-china-ip.yml'

jobs:
  update-ip-ranges:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.10'

    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y xz-utils curl

    - name: Download APNIC data
      run: |
        curl -o apnic-data.txt https://ftp.apnic.net/apnic/stats/apnic/delegated-apnic-latest
        echo "Downloaded APNIC data"

    - name: Parse China IP ranges
      run: |
        python3 << 'EOF'
        import re
        import ipaddress

        # Read APNIC data
        with open('apnic-data.txt', 'r') as f:
            lines = f.readlines()

        ipv4_ranges = []
        ipv6_ranges = []

        # Parse lines
        for line in lines:
            # Skip comments and headers
            if line.startswith('#') or '|CN|' not in line:
                continue

            parts = line.strip().split('|')
            if len(parts) < 5:
                continue

            registry = parts[0]
            country = parts[1]
            ip_type = parts[2]
            start = parts[3]
            value = parts[4]

            if country != 'CN':
                continue

            try:
                if ip_type == 'ipv4':
                    # Convert to CIDR notation
                    count = int(value)
                    # Calculate prefix length from count
                    import math
                    prefix_len = 32 - int(math.log2(count))
                    cidr = f"{start}/{prefix_len}"
                    # Validate the network
                    network = ipaddress.IPv4Network(cidr, strict=False)
                    ipv4_ranges.append(str(network))
                elif ip_type == 'ipv6':
                    # IPv6 value is already prefix length
                    prefix_len = int(value)
                    cidr = f"{start}/{prefix_len}"
                    # Validate the network
                    network = ipaddress.IPv6Network(cidr, strict=False)
                    ipv6_ranges.append(str(network))
            except Exception as e:
                print(f"Error processing: {line.strip()}: {e}")
                continue

        # Sort ranges
        ipv4_ranges.sort(key=lambda x: ipaddress.IPv4Network(x))
        ipv6_ranges.sort(key=lambda x: ipaddress.IPv6Network(x))

        # Write IPv4 ranges
        with open('china_ipv4_ranges.txt', 'w') as f:
            for cidr in ipv4_ranges:
                f.write(f"{cidr}\n")
        print(f"Wrote {len(ipv4_ranges)} IPv4 ranges")

        # Write IPv6 ranges
        with open('china_ipv6_ranges.txt', 'w') as f:
            for cidr in ipv6_ranges:
                f.write(f"{cidr}\n")
        print(f"Wrote {len(ipv6_ranges)} IPv6 ranges")
        EOF

    - name: Generate SHA256 checksums
      run: |
        sha256sum china_ipv4_ranges.txt > china_ipv4_ranges.txt.sha256sum
        sha256sum china_ipv6_ranges.txt > china_ipv6_ranges.txt.sha256sum
        echo "Generated SHA256 checksums"

    - name: Create compressed files
      run: |
        # Create XZ compressed versions
        xz -zk china_ipv4_ranges.txt
        xz -zk china_ipv6_ranges.txt

        # Create gzip compressed versions
        gzip -9k china_ipv4_ranges.txt
        gzip -9k china_ipv6_ranges.txt

        # Generate checksums for compressed files
        sha256sum china_ipv4_ranges.txt.xz > china_ipv4_ranges.txt.xz.sha256sum
        sha256sum china_ipv6_ranges.txt.xz > china_ipv6_ranges.txt.xz.sha256sum
        sha256sum china_ipv4_ranges.txt.gz > china_ipv4_ranges.txt.gz.sha256sum
        sha256sum china_ipv6_ranges.txt.gz > china_ipv6_ranges.txt.gz.sha256sum

        echo "Created compressed files (XZ and GZ) with checksums"

    - name: Check for changes
      id: check_changes
      run: |
        # Compare with previous release files if they exist
        echo "changes=true" >> $GITHUB_OUTPUT

        # Always generate summary for releases
        echo "## IP Ranges Summary" > change_summary.txt
        echo "" >> change_summary.txt

        # Count IP ranges
        ipv4_count=$(wc -l < china_ipv4_ranges.txt)
        ipv6_count=$(wc -l < china_ipv6_ranges.txt)
        echo "- IPv4 ranges: $ipv4_count" >> change_summary.txt
        echo "- IPv6 ranges: $ipv6_count" >> change_summary.txt
        echo "" >> change_summary.txt
        echo "Generated at: $(date '+%Y-%m-%d %H:%M:%S UTC')" >> change_summary.txt

    # Skip commit step - we only create releases, not commit to repo

    - name: Create release
      if: steps.check_changes.outputs.changes == 'true'
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        # Create release for:
        # 1. Manual runs (workflow_dispatch)
        # 2. Weekly scheduled runs (every Sunday)
        # 3. Push to main branch with 'release' in commit message

        should_release=false

        # Check if manual trigger
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          echo "Manual trigger detected - will create release"
          should_release=true
        fi

        # Check if it's Sunday for scheduled runs
        if [ "${{ github.event_name }}" = "schedule" ] && [ $(date +%u) -eq 7 ]; then
          echo "Sunday scheduled run - will create release"
          should_release=true
        fi

        # Check if commit message contains 'release'
        if [[ "${{ github.event.head_commit.message }}" == *"release"* ]]; then
          echo "Commit message contains 'release' - will create release"
          should_release=true
        fi

        if [ "$should_release" = true ]; then
          tag_name="ip-ranges-$(date '+%Y%m%d-%H%M%S')"

          # Create release notes
          echo "# China IP Ranges Update - $(date '+%Y-%m-%d')" > release_notes.md
          echo "" >> release_notes.md
          echo "## Files" >> release_notes.md
          echo "- china_ipv4_ranges.txt - IPv4 CIDR ranges" >> release_notes.md
          echo "- china_ipv6_ranges.txt - IPv6 CIDR ranges" >> release_notes.md
          echo "- .sha256sum files - SHA256 checksums" >> release_notes.md
          echo "- .gz files - Gzip compressed versions" >> release_notes.md
          echo "- .xz files - XZ compressed versions" >> release_notes.md
          echo "" >> release_notes.md
          echo "## Statistics" >> release_notes.md
          echo "- IPv4 ranges: $(wc -l < china_ipv4_ranges.txt)" >> release_notes.md
          echo "- IPv6 ranges: $(wc -l < china_ipv6_ranges.txt)" >> release_notes.md
          echo "" >> release_notes.md
          echo "## Source" >> release_notes.md
          echo "Data parsed from APNIC delegated statistics" >> release_notes.md

          # Create tag and release
          git tag -a "$tag_name" -m "China IP ranges update $(date '+%Y-%m-%d')"
          git push origin "$tag_name"

          # Create GitHub release using GitHub CLI
          gh release create "$tag_name" \
            --title "IP Ranges Update - $(date '+%Y-%m-%d %H:%M')" \
            --notes-file release_notes.md \
            china_ipv4_ranges.txt \
            china_ipv6_ranges.txt \
            china_ipv4_ranges.txt.sha256sum \
            china_ipv6_ranges.txt.sha256sum \
            china_ipv4_ranges.txt.gz \
            china_ipv4_ranges.txt.gz.sha256sum \
            china_ipv4_ranges.txt.xz \
            china_ipv4_ranges.txt.xz.sha256sum \
            china_ipv6_ranges.txt.gz \
            china_ipv6_ranges.txt.gz.sha256sum \
            china_ipv6_ranges.txt.xz \
            china_ipv6_ranges.txt.xz.sha256sum

          echo "✅ Release created: $tag_name"
        else
          echo "ℹ️ No release created (conditions not met)"
        fi